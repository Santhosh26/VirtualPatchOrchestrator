import os
import xml.etree.ElementTree as ET
from openai import OpenAI


import paramiko

################################################################################
# 1. Parse <CriticalIssues> from critical_issues.xml
# 2. For each <Issue>, call OpenAI API to get ModSecurity rules in JSON.
# 3. Save rules into customrules.conf
################################################################################

def generate_modsecurity_rules_from_issues(
    critical_issues_file: str,
    openai_api_key: str,
    output_rule_file: str
):
    """
    1. Reads critical_issues_file (XML).
    2. For each <Issue>, calls OpenAI to generate ModSecurity rules (in JSON).
    3. Writes all rules to output_rule_file (e.g., 'customrules.conf').
    """
    # Set your client and OpenAI API key

    client = OpenAI(api_key=openai_api_key)

    # Parse XML
    tree = ET.parse(critical_issues_file)
    root = tree.getroot()  # Should be <CriticalIssues>
    issues = root.findall("Issue")

    # Prepare a file to store *all* the rules.
    with open(output_rule_file, "w", encoding="utf-8") as f_rules:
        f_rules.write("# Custom ModSecurity Rules generated by OpenAI\n\n")

        for idx, issue_elem in enumerate(issues, start=1):
            # Convert the <Issue> block to string
            issue_xml_str = ET.tostring(issue_elem, encoding="unicode")
            issue_xml_str = "Here is the DAST Finding: " + issue_xml_str
            

            system_prompt = (
                """You are an expert WAF engineer specializing in analyzing and mitigating security vulnerabilities. Your task is to carefully analyze findings from a DAST scanner, which are provided in an XML file format. The XML findings include detailed information about the security vulnerabilities within <ISSUE> tags. Inside each <ISSUE> tag, there are key elements containing crucial attack data:

<URL>: The targeted URL.
Host: The target host.
Port: The port used in the attack.
AttackMethod: The attack vector or method used.
AttackParam: The specific parameter targeted.
VulnerableSession: Contains the request headers and body responsible for the vulnerability.
TriggerSession: The session that led to the vulnerability being triggered.
Severity: The severity of the attack.
<RawResponse>: The raw server response confirming the vulnerability.
Your task: Based on the provided DAST scanner output, create an appropriate ModSecurity WAF rule that can successfully block the identified attack. Your ModSecurity rule must account for specific details such as attack parameters, headers, and payloads found in the DAST XML report.
Generate a ModSecurity WAF rule tailored to block the attack described in the DAST XML findings, ensuring the following:

Incorporate key attack details such as AttackParam, VulnerableSession, and RawResponse.
Provide meaningful tags, log data, and severity levels.
Ensure the rule is compatible with ModSecurity engine conventions.
Ensure to respond with rule only and dont add any text explaining the rule.
Ensure not to add *apache* keyword in the beginning"""
            )

            # Call OpenAI ChatCompletion
            try:
                response = client.chat.completions.create(
                    model="gpt-4o",  # or 'gpt-4', etc.
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": issue_xml_str},
                    ],
                    temperature=0.5,
                )
                
                ai_answer = response.choices[0].message.content.strip()
                # print("AI Response after rule generation: ", ai_answer )

            except Exception as e:
                print(f"[Error] OpenAI call failed for Issue #{idx}: {e}")
                continue

            # Write the returned JSON (the rules) to the conf file
            f_rules.write(f"# ---- Issue #{idx} ----\n")
            f_rules.write(ai_answer + "\n\n")

    print(f"All generated rules written to: {output_rule_file}")


################################################################################
# 4. SSH to remote server (key-based), upload the file, test Nginx, reload if OK
################################################################################
def update_modsecurity_on_remote(
    ssh_host: str,
    ssh_user: str,
    pem_file: str,
    local_rule_file: str,
    remote_rule_path: str
):
    """
    1. SSH to remote server with a .pem file (key-based auth).
    2. Upload local_rule_file to /tmp.
    3. sudo mv from /tmp to remote_rule_path.
    4. Check 'nginx -t' on remote server.
    5. If OK, 'sudo systemctl restart nginx'.
    """
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    somekey = paramiko.RSAKey.from_private_key_file(pem_file)

    try:
        print(f"[SSH] Connecting to {ssh_host} as {ssh_user} (key-based)...")
        ssh_client.connect(
            hostname=ssh_host,
            username=ssh_user,
            pkey=somekey,
            timeout=10
        )

        # 1) Upload to /tmp
        print(f"[SSH] Connected. Uploading {local_rule_file} to /tmp ...")
        tmp_path = "/tmp/customrules.conf"

        sftp = ssh_client.open_sftp()
        sftp.put(local_rule_file, tmp_path)
        sftp.close()

        # 2) Move it into the real location with sudo
        print(f"[SSH] Moving {tmp_path} to {remote_rule_path} via sudo ...")
        mv_cmd = f"sudo mv {tmp_path} {remote_rule_path}"

        stdin, stdout, stderr = ssh_client.exec_command(mv_cmd)
        exit_code = stdout.channel.recv_exit_status()
        if exit_code != 0:
            err_txt = stderr.read().decode()
            print(f"[SSH] Could not move file: {err_txt}")
            return
        else:
            print("[SSH] File moved with sudo successfully.")

        # 3) Check Nginx config
        print("[SSH] Checking Nginx configuration with 'nginx -t' ...")
        stdin, stdout, stderr = ssh_client.exec_command("sudo nginx -t")
        config_test_output = stdout.read().decode().strip()
        config_test_error = stderr.read().decode().strip()

        if "ok" or "successful" in config_test_error.lower():
            print("[SSH] Nginx config test: SUCCESS")
            print("[SSH] Restarting Nginx (sudo, no password assumed)...")
            ssh_client.exec_command("sudo systemctl restart nginx")
            print("[SSH] Nginx has been restarted successfully.")
        else:
            print("[SSH] Nginx config test: FAILED!")
            print("[SSH] STDOUT:", config_test_output)
            print("[SSH] STDERR:", config_test_error)
            print("[SSH] Not restarting Nginx due to errors above.")

    except Exception as e:
        print(f"[SSH Error]: {e}")

    finally:
        ssh_client.close()
        print("[SSH] Connection closed.")


# def remove_triple_backticks(input_file, output_file):
#     """
#     Reads the input_file line by line and writes to output_file,
#     dropping any line that contains the triple backticks (```).
#     """
#     with open(input_file, 'r', encoding='utf-8') as fin, \
#          open(output_file, 'w', encoding='utf-8') as fout:

#         for line in fin:
#             if '```' in line:
#                 # skip or remove just the backticks
#                 continue
#             fout.write(line)

import re

def fix_custom_rules(input_file: str, output_file: str, start_rule_id: int = 10000):
    """
    1) Reads 'input_file' line by line.
    2) Removes any triple backticks (```).
    3) Replaces any 'id:someNumber' with an incremental unique ID, 
       starting from 'start_rule_id'.
    4) Writes the cleaned result to 'output_file'.

    Example usage:
       fix_custom_rules("customrules.conf", "customrules-final.conf", 20000)
    """
    # Compile a regex that captures 'id:' plus the digits after it.
    # e.g. id:1001  or  id:  1001
    id_pattern = re.compile(r"(id\s*:\s*)(\d+)")
    
    rule_id_counter = start_rule_id

    with open(input_file, "r", encoding="utf-8") as fin, \
         open(output_file, "w", encoding="utf-8") as fout:

        for line in fin:
            # 1) Remove triple backticks
            line = line.replace("```", "")

            # 2) Replace any 'id:XXXX' with a new, unique ID
            def replace_id(match):
                nonlocal rule_id_counter
                prefix = match.group(1)  # e.g. "id:" (with possible spaces)
                # old_id = match.group(2)  # not used, but you could inspect the old id
                new_line = f"{prefix}{rule_id_counter}"
                rule_id_counter += 1
                return new_line

            line = id_pattern.sub(replace_id, line)

            # Write cleaned line
            fout.write(line)

    print(f"Done cleaning triple backticks and ensuring unique IDs. "
          f"Output => {output_file} (first ID used: {start_rule_id})")

################################################################################
# MAIN SCRIPT
################################################################################

if __name__ == "__main__":
#     # 1) Generate all ModSecurity rules by calling OpenAI for each <Issue>
#     critical_issues_xml = "critical_issues.xml"       # your input XML
#     openai_api_key = "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"            
    
    
  
#     generate_modsecurity_rules_from_issues(
#         critical_issues_file=critical_issues_xml,
#         openai_api_key=openai_api_key,
#         output_rule_file="customrules.conf"
#     )
#     fix_custom_rules(
#     input_file="customrules.conf",
#     output_file="customrules-final.conf",
#     start_rule_id=9999010101  # or any large enough number
# )
    local_custom_rules_path = "customrules-final.conf" 
    # 2) SSH to the server (using .pem file) and upload the rules.
    ssh_host = "15.228.46.121"
    ssh_user = "ubuntu"                     # Typically the default user on AWS/Ubuntu
    pem_file = "C:\Santhosh-Files\Fortify_Lab-new\EC2-New-keypair\Fortify-keypair.pem"      # e.g. "~/.ssh/id_rsa" or your .pem path
    remote_path = "/usr/local/modsecurity-crs/rules/customrules.conf"  # location in the remote server
    
    update_modsecurity_on_remote(
        ssh_host=ssh_host,
        ssh_user=ssh_user,
        pem_file=pem_file,
        local_rule_file=local_custom_rules_path,
        remote_rule_path=remote_path
    )
